  /// \file CaloHit.h
/*
 *
 * CaloHit.h header template automatically generated by a class generator
 * Creation date : lun. avr. 28 2014
 *
 * This file is part of SDHCALEventDisplay libraries.
 * 
 * SDHCALEventDisplay is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * SDHCALEventDisplay is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SDHCALEventDisplay.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef CALOHIT_H
#define CALOHIT_H

#include "Typedef.h"
#include "CartesianVector.h"

/**
 * @brief CaloHitCell class.
 * A simple class that handle the cell info
 */
class CaloHitCell
{
public:

	unsigned int      m_iCell;
	unsigned int      m_jCell;
	unsigned int      m_layer;

	float              m_cellSize0;
	float              m_cellSize1;
	float              m_cellThickness;
};

/**
 * @brief DensityInfo class.
 * A simple class that handle the density of a calo hit
 */
class DensityInfo
{
public:

	DensityInfo()
	 : m_weightedDensity2D(0.f),
	   m_unWeightedDensity2D(0.f),
	   m_weightedDensity3D(0.f),
	   m_unWeightedDensity3D(0.f) {}

	float m_weightedDensity2D;
	float m_unWeightedDensity2D;
	float m_weightedDensity3D;
	float m_unWeightedDensity3D;
};

/** 
 * @brief CaloHit class
 */ 
class CaloHit
{
 public:

	CaloHit(CartesianVector position, CaloHitCell cell, SemiDigitalThreshold semiDigitalThreshold);
	CaloHit(CaloHit *pCaloHit);
	~CaloHit();

	SemiDigitalThreshold     getSemiDigitalThreshold() const;
	const CartesianVector&  getPosition() const;
	const CaloHitCell&      getCell() const;
	const DensityInfo&      getDensityInfo() const;
	DensityInfo&             getDensityInfo();

	// helper func for std::sort by increasing layer
	static bool sortByLayer(const CaloHit *pCaloHit1, const CaloHit *pCaloHit2)
	{ return ( pCaloHit1->getCell().m_layer < pCaloHit2->getCell().m_layer ); }

protected:

	SemiDigitalThreshold     m_semiDigitalThreshold;
	CartesianVector          m_position;
	CaloHitCell              m_cell;
	DensityInfo              m_densityInfo;
};

//-------------------------------------------------------------------------------------------

inline SemiDigitalThreshold CaloHit::getSemiDigitalThreshold() const
{
	return m_semiDigitalThreshold;
}

//-------------------------------------------------------------------------------------------

inline const CartesianVector &CaloHit::getPosition() const
{
	return m_position;
}

//-------------------------------------------------------------------------------------------

inline const CaloHitCell &CaloHit::getCell() const
{
	return m_cell;
}

//-------------------------------------------------------------------------------------------

inline const DensityInfo &CaloHit::getDensityInfo() const
{
	return m_densityInfo;
}

//-------------------------------------------------------------------------------------------

inline DensityInfo &CaloHit::getDensityInfo()
{
	return m_densityInfo;
}

#endif  //  CALOHIT_H
