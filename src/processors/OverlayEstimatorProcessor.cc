  /// \file OverlayEstimatorProcessor.cc
/*
 *
 * OverlayEstimatorProcessor.cc source template automatically generated by a class generator
 * Creation date : mar. janv. 13 2015
 *
 * This file is part of SDHCAL libraries.
 * 
 * SDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * SDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "OverlayEstimatorProcessor.h"
#include "TTreeWrapper.h"

#include "marlin/Global.h"
#include "marlin/VerbosityLevels.h"

// lcio includes
#include "UTIL/CellIDDecoder.h"
#include "EVENT/CalorimeterHit.h"

// std
#include <limits>
#include <cstdio>

OverlayEstimatorProcessor aOverlayEstimatorProcessor;

//-----------------------------------------------------------------------------

OverlayEstimatorProcessor::OverlayEstimatorProcessor()
 : Processor("OverlayEstimatorProcessor")
{
	_description = "Estimate the error done by overlaying two pions showers";

	registerProcessorParameter("DecoderString" ,
				 "decoder string for cell ID decoder" ,
				 m_decoderString,
				 std::string("M:3,S-1:3,I:9,J:9,K-1:6"));

	registerProcessorParameter("SDHCALCollectionName" ,
				 "collection name for SDHCAL hits" ,
				 m_sdhcalCollectionName,
				 std::string("HCALBarrel"));

	std::vector<std::string> ijkVec;
	ijkVec.push_back("I");
	ijkVec.push_back("J");
	ijkVec.push_back("K-1");

	registerProcessorParameter("IJKEncoding",
				 "I J K hit encoding",
				 m_ijkEncoding,
				 ijkVec);

	registerProcessorParameter("RootOutputFile" ,
				 "The root output file name" ,
				 m_rootOutputFileName,
				 std::string("output.root"));

	registerProcessorParameter("RootOutputTree" ,
				 "The root output tree name" ,
				 m_rootOutputTreeName,
				 std::string("OverlayEstimator"));
}

//-----------------------------------------------------------------------------

OverlayEstimatorProcessor::~OverlayEstimatorProcessor() 
{

}

//-----------------------------------------------------------------------------

void OverlayEstimatorProcessor::init()
{
	m_pRootFile = new TFile(m_rootOutputFileName.c_str(), "RECREATE");

	m_pTreeWrapper = new TTreeWrapper();
	m_pTreeWrapper->AddTree(m_rootOutputTreeName);
	m_pRootTree = m_pTreeWrapper->GetTree(m_rootOutputTreeName);
}

//-----------------------------------------------------------------------------

void OverlayEstimatorProcessor::processRunHeader(EVENT::LCRunHeader* run)
{
	/* nop */
}

//-----------------------------------------------------------------------------

void OverlayEstimatorProcessor::processEvent(EVENT::LCEvent *evt)
{
	clear();

	std::cout  << "OverlayEstimatorProcessor - processing event no " << evt->getEventNumber() << std::endl;

	UTIL::CellIDDecoder<CalorimeterHit>::setDefaultEncoding(m_decoderString);
	EVENT::LCCollection *pCollection = 0;

	try
	{
		pCollection = evt->getCollection( m_sdhcalCollectionName );
	}
	catch( DataNotAvailableException &e )
	{
		streamlog_out(ERROR) << "LCIO exception thrown : " << e.what() << std::endl;
		throw marlin::StopProcessingException(this);
	}

	UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder(pCollection);

	for(unsigned int i=0 ; i<pCollection->getNumberOfElements() ; i++)
	{
		if( pCollection->getTypeName() != LCIO::CALORIMETERHIT )
			throw marlin::StopProcessingException(this);

		CalorimeterHit *caloHit = static_cast<CalorimeterHit*> (pCollection->getElementAt(i));

		int type = caloHit->getType();

		m_calorimeterHitList.push_back(caloHit);

		if(type == 1)
		{
			m_calorimeterHitType1List.push_back(caloHit);
			m_calorimeterHitParticle1List.push_back(caloHit);
		}
		else if(type == 2)
		{
			m_calorimeterHitType2List.push_back(caloHit);
			m_calorimeterHitParticle2List.push_back(caloHit);
		}
		else if(type == 3)
		{
			m_calorimeterHitType3List.push_back(caloHit);
			m_calorimeterHitParticle1List.push_back(caloHit);
			m_calorimeterHitParticle2List.push_back(caloHit);
		}
	}

	m_pTreeWrapper->Set(m_rootOutputTreeName, "nHitType3", (int)m_calorimeterHitType3List.size());

	m_pTreeWrapper->Fill(m_rootOutputTreeName);
//	m_pTreeWrapper->Set(m_rootOutputTreeName, "nHitType3", (int)m_calorimeterHitType3List.size());
}

//---------------------------------------------------------------------------------------------

void OverlayEstimatorProcessor::check( LCEvent *evt )
{
	/* nop */
}

//---------------------------------------------------------------------------------------------

void OverlayEstimatorProcessor::end()
{
	m_pRootTree->SetDirectory(m_pRootFile);
	m_pRootFile->Write();
	m_pRootTree->SetDirectory(0);
	m_pRootFile->Close();

	delete m_pTreeWrapper;
	delete m_pRootFile;
}



void OverlayEstimatorProcessor::clear()
{
	m_calorimeterHitList.clear(); // all the hits
	m_calorimeterHitType1List.clear();   // only type 1
	m_calorimeterHitType2List.clear();   // only type 2
	m_calorimeterHitType3List.clear();   // only type 3
	m_calorimeterHitParticle1List.clear();  // only type 1+3
	m_calorimeterHitParticle2List.clear();
}


