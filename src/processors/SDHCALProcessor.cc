  /// \file SDHCALProcessor.cc
/*
 *
 * SDHCALProcessor.cc source template automatically generated by a class generator
 * Creation date : sam. mai 31 2014
 *
 * This file is part of SDHCAL libraries.
 * 
 * SDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * SDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "SDHCALProcessor.h"

// sdhcal
#include "CaloHit.h"
#include "CaloHitHelper.h"
#include "TTreeWrapper.h"

// lcio
#include "EVENT/LCCollection.h"

// root
#include "TFile.h"
#include "TTree.h"

// marlin
#include "marlin/Exceptions.h"

// processor instance
SDHCALProcessor aSDHCALProcessor;


SDHCALProcessor::SDHCALProcessor() :
		marlin::Processor("SDHCALProcessor")
{
	_description = "SDHCALProcessor. Process SDHCAL data for various analysis purpose";

	registerInputCollection(LCIO::CALORIMETERHIT,
						 "HCalCaloHitCollection",
						 "Name of the HCAL calo hit collection",
						 m_hCalCaloHitCollection,
						 std::string(""));

	registerProcessorParameter("RootOuputFileName",
						 "Name of the ROOT output file for analysis",
						 m_rootFileName,
						 std::string(""));

	registerProcessorParameter("RootTreeName",
						 "Name of the root tree",
						 m_rootTreeName,
						 std::string(""));
}

//-------------------------------------------------------------------------------------------

SDHCALProcessor::~SDHCALProcessor() 
{

}

//-------------------------------------------------------------------------------------------

void SDHCALProcessor::init()
{
	if(!m_rootFileName.empty())
	{
		m_pRootFile = TFile::Open(m_rootFileName.c_str(), "RECREATE", m_rootFileName.c_str());

		if(NULL == m_pRootFile)
		{
			streamlog_out(ERROR) << "Couldn't create root file : " << m_rootFileName << std::endl;
			throw marlin::StopProcessingException(this);
		}

		m_pRootFile->cd();
		m_pTTreeWrapper = new TTreeWrapper();
		m_pTTreeWrapper->AddTree(m_rootTreeName);
		m_pTTreeWrapper->GetTree(m_rootTreeName)->SetDirectory(m_pRootFile);
	}
}

//-------------------------------------------------------------------------------------------

void SDHCALProcessor::processRunHeader(EVENT::LCRunHeader *pLCRunHeader)
{
	std::cout << "Detector Name " << pLCRunHeader->getDetectorName() << ", Run " << pLCRunHeader->getRunNumber() <<  std::endl;
}

//-------------------------------------------------------------------------------------------

void SDHCALProcessor::processEvent(EVENT::LCEvent *pLCEvent)
{
	streamlog_out(MESSAGE) << "Processing event no " << pLCEvent->getEventNumber() << std::endl;
	try
	{
		const EVENT::LCCollection *pCaloHitCollection = pLCEvent->getCollection(m_hCalCaloHitCollection);
		const int nElements(pCaloHitCollection->getNumberOfElements());

		if (0 == nElements)
			return;

		CaloHitHelper::loadCaloHitCollection(pCaloHitCollection, &m_caloHitList, &m_orderedCaloHitList);

		this->fillRootTree();
		this->clearContent();

	}
	catch(EVENT::Exception &exception)
	{
		std::cerr << "Exception caught : Failed to load event. Message : " << exception.what() << std::endl;
	}
}

//-------------------------------------------------------------------------------------------

void SDHCALProcessor::check(EVENT::LCEvent *pLCEvent)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------

void SDHCALProcessor::end()
{
	m_pTTreeWrapper->Print(m_rootTreeName);

	m_pRootFile->Write();
	m_pRootFile->Close();
	m_pRootFile->Delete();

	delete m_pTTreeWrapper;
}


void SDHCALProcessor::fillRootTree()
{
	iCellVector.clear();
	jCellVector.clear();
	kCellVector.clear();
	xPosition.clear();
	yPosition.clear();
	zPosition.clear();
	semiDigitalThresholdVector.clear();
	weighted2DDensities.clear();
	unWeighted2DDensities.clear();
	weighted3DDensities.clear();
	unWeighted3DDensities.clear();
	weighted2DDensitySum = 0.f;
	unWeighted2DDensitySum = 0.f;
	weighted3DDensitySum = 0.f;
	unWeighted3DDensitySum = 0.f;
	nHit = 0;
	nHit1 = 0;
	nHit2 = 0;
	nHit3 = 0;

	for(CaloHitList::iterator iter = m_caloHitList.begin() , endIter = m_caloHitList.end() ; endIter != iter ; ++iter)
	{
		CaloHit *pCaloHit = *iter;

		iCellVector.push_back(pCaloHit->getCell().m_iCell);
		jCellVector.push_back(pCaloHit->getCell().m_jCell);
		kCellVector.push_back(pCaloHit->getCell().m_layer);

		xPosition.push_back(pCaloHit->getPosition().getX());
		yPosition.push_back(pCaloHit->getPosition().getY());
		zPosition.push_back(pCaloHit->getPosition().getZ());

		semiDigitalThresholdVector.push_back(static_cast<int>(pCaloHit->getSemiDigitalThreshold()));

//		weighted2DDensities.push_back(pCaloHit->getDensityInfo().m_weightedDensity2D);
//		unWeighted2DDensities.push_back(pCaloHit->getDensityInfo().m_unWeightedDensity2D);
//		weighted3DDensities.push_back(pCaloHit->getDensityInfo().m_weightedDensity3D);
//		unWeighted3DDensities.push_back(pCaloHit->getDensityInfo().m_unWeightedDensity3D);
//
//		weighted2DDensitySum += pCaloHit->getDensityInfo().m_weightedDensity2D;
//		unWeighted2DDensitySum += pCaloHit->getDensityInfo().m_unWeightedDensity2D;
//		weighted3DDensitySum += pCaloHit->getDensityInfo().m_weightedDensity3D;
//		unWeighted3DDensitySum += pCaloHit->getDensityInfo().m_unWeightedDensity3D;

		if(pCaloHit->getSemiDigitalThreshold() == THRESHOLD_1)
			nHit1 ++;
		if(pCaloHit->getSemiDigitalThreshold() == THRESHOLD_2)
			nHit2 ++;
		if(pCaloHit->getSemiDigitalThreshold() == THRESHOLD_3)
			nHit3 ++;

  nHit ++;
	}


 m_pRootFile->cd();

 m_pTTreeWrapper->Set(m_rootTreeName, "NHit", nHit);
 m_pTTreeWrapper->Set(m_rootTreeName, "NHit1", nHit1);
 m_pTTreeWrapper->Set(m_rootTreeName, "NHit2", nHit2);
 m_pTTreeWrapper->Set(m_rootTreeName, "NHit3", nHit3);
 m_pTTreeWrapper->Set(m_rootTreeName, "I", &iCellVector);
 m_pTTreeWrapper->Set(m_rootTreeName, "J", &jCellVector);
 m_pTTreeWrapper->Set(m_rootTreeName, "K", &kCellVector);
 m_pTTreeWrapper->Set(m_rootTreeName, "x", &xPosition);
 m_pTTreeWrapper->Set(m_rootTreeName, "y", &yPosition);
 m_pTTreeWrapper->Set(m_rootTreeName, "z", &zPosition);
 m_pTTreeWrapper->Set(m_rootTreeName, "threshold", &semiDigitalThresholdVector);
// m_pTTreeWrapper->Set(m_rootTreeName, "WeightedDensity2D", &weighted2DDensities);
// m_pTTreeWrapper->Set(m_rootTreeName, "UnWeightedDensity2D", &unWeighted2DDensities);
// m_pTTreeWrapper->Set(m_rootTreeName, "WeightedDensity3D", &weighted3DDensities);
// m_pTTreeWrapper->Set(m_rootTreeName, "UnWeightedDensity3D", &unWeighted3DDensities);
// m_pTTreeWrapper->Set(m_rootTreeName, "WeightedDensity2DSum", weighted2DDensitySum);
// m_pTTreeWrapper->Set(m_rootTreeName, "UnWeightedDensity2DSum", unWeighted2DDensitySum);
// m_pTTreeWrapper->Set(m_rootTreeName, "WeightedDensity3DSum", weighted3DDensitySum);
// m_pTTreeWrapper->Set(m_rootTreeName, "UnWeightedDensity3DSum", unWeighted3DDensitySum);

	m_pTTreeWrapper->Fill(m_rootTreeName);
}


void SDHCALProcessor::clearContent()
{
	for(CaloHitList::iterator iter = m_caloHitList.begin() , endIter = m_caloHitList.end() ; endIter != iter ; ++iter)
	{
		delete *iter;
	}

	m_caloHitList.clear();
	m_orderedCaloHitList.clear();
}

